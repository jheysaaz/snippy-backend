# Database Documentation

Complete database schema and optimization details for Snippy Backend.

## Database Technology

- **PostgreSQL**: Version 16-alpine
- **Driver**: `lib/pq` for Go
- **Extensions**: `uuid-ossp` for UUID generation

## Connection Configuration

The application uses connection pooling for optimal performance:

```go
MaxOpenConns:    25  // Maximum number of open connections
MaxIdleConns:    5   // Maximum number of idle connections
ConnMaxIdleTime: 5 minutes
```

### Environment Variables

```bash
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=snippy
```

---

## Schema

### Users Table

Stores user account information with secure password hashing.

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Fields:**

- `id`: UUID primary key (auto-generated by PostgreSQL)
- `username`: Unique username, 3-50 characters
- `email`: Unique email address
- `password_hash`: Argon2id hash of the password
- `created_at`: Timestamp of account creation
- `updated_at`: Timestamp of last update (auto-updated by trigger)

**Indexes:**

```sql
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
```

**Constraints:**

- Primary Key: `id`
- Unique: `username`, `email`

---

### Snippets Table

Stores code snippets with categorization and shortcuts.

```sql
CREATE TABLE snippets (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100) NOT NULL,
    shortcut VARCHAR(50) NOT NULL,
    content TEXT NOT NULL,
    tags TEXT[],
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Fields:**

- `id`: Auto-incrementing integer primary key
- `title`: Snippet title (max 255 characters)
- `description`: Optional detailed description
- `category`: Category classification (e.g., "git", "docker", "kubernetes")
- `shortcut`: Short string identifier for quick access (no spaces)
- `content`: The actual snippet content/command
- `tags`: Array of tags for additional categorization
- `user_id`: Foreign key to users table (nullable, set to NULL on user deletion)
- `created_at`: Timestamp of snippet creation
- `updated_at`: Timestamp of last update (auto-updated by trigger)

**Indexes:**

```sql
-- B-tree indexes for fast lookups
CREATE INDEX idx_snippets_created_at ON snippets(created_at DESC);
CREATE INDEX idx_snippets_category ON snippets(category);
CREATE INDEX idx_snippets_shortcut ON snippets(shortcut);

-- GIN index for array operations on tags
CREATE INDEX idx_snippets_tags ON snippets USING GIN(tags);

-- GIN index for full-text search
CREATE INDEX idx_snippets_search ON snippets USING GIN(
    to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, ''))
);
```

**Constraints:**

- Primary Key: `id`
- Foreign Key: `user_id` references `users(id)` with `ON DELETE SET NULL`

---

## Database Triggers

### Auto-Update Timestamps

Both tables have triggers that automatically update the `updated_at` timestamp on any row modification.

```sql
-- Function to update timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger for users table
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Trigger for snippets table
CREATE TRIGGER update_snippets_updated_at
    BEFORE UPDATE ON snippets
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## Performance Optimizations

### 1. B-Tree Indexes

Standard B-tree indexes for fast equality and range queries:

- **`idx_users_username`**: Fast username lookups
- **`idx_users_email`**: Fast email lookups
- **`idx_snippets_created_at DESC`**: Optimized for `ORDER BY created_at DESC`
- **`idx_snippets_category`**: Fast category filtering
- **`idx_snippets_shortcut`**: Quick shortcut lookups

### 2. GIN Indexes

Generalized Inverted Indexes for advanced queries:

#### Tag Array Index

```sql
CREATE INDEX idx_snippets_tags ON snippets USING GIN(tags);
```

Enables efficient queries like:

```sql
WHERE 'docker' = ANY(tags)
```

#### Full-Text Search Index

```sql
CREATE INDEX idx_snippets_search ON snippets USING GIN(
    to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, ''))
);
```

Enables fast full-text search:

```sql
WHERE to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, ''))
      @@ plainto_tsquery('english', 'search term')
```

### 3. Connection Pooling

The application maintains a pool of database connections to reduce connection overhead:

- **Max Open Connections**: 25 concurrent connections
- **Max Idle Connections**: 5 connections kept alive
- **Idle Timeout**: 5 minutes before closing idle connections

### 4. Prepared Statements

All queries use parameterized statements (`$1`, `$2`, etc.) which:

- Prevent SQL injection
- Allow PostgreSQL to cache query plans
- Improve performance on repeated queries

---

## Query Examples

### 1. Get Snippets by Category

```sql
SELECT id, title, description, category, shortcut, content, tags, user_id, created_at, updated_at
FROM snippets
WHERE category = $1
ORDER BY created_at DESC;
```

### 2. Full-Text Search

```sql
SELECT id, title, description, category, shortcut, content, tags, user_id, created_at, updated_at
FROM snippets
WHERE to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, ''))
      @@ plainto_tsquery('english', $1)
ORDER BY created_at DESC;
```

### 3. Filter by Tag

```sql
SELECT id, title, description, category, shortcut, content, tags, user_id, created_at, updated_at
FROM snippets
WHERE $1 = ANY(tags)
ORDER BY created_at DESC;
```

### 4. Combined Filters with Limit

```sql
SELECT id, title, description, category, shortcut, content, tags, user_id, created_at, updated_at
FROM snippets
WHERE category = $1
  AND $2 = ANY(tags)
  AND to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, ''))
      @@ plainto_tsquery('english', $3)
ORDER BY created_at DESC
LIMIT $4;
```

---

## Data Relationships

```
users (1) ───────── (0..n) snippets
  id                        user_id
```

- One user can have many snippets
- Snippets can exist without a user (user_id is nullable)
- When a user is deleted, their snippets remain but user_id is set to NULL

---

## Backup and Restore

### Backup Database

```bash
docker-compose exec postgres pg_dump -U postgres snippy > backup.sql
```

### Restore Database

```bash
docker-compose exec -T postgres psql -U postgres snippy < backup.sql
```

### Backup with Docker Volume

```bash
docker run --rm -v snippy-backend_postgres_data:/data -v $(pwd):/backup alpine \
  tar czf /backup/postgres_backup.tar.gz -C /data .
```

---

## Migration Strategy

Currently, the application uses a simple initialization script in `database.go` that creates tables if they don't exist. For production use, consider implementing a proper migration tool:

### Recommended Tools

1. **golang-migrate/migrate**: Versioned migrations
2. **goose**: Migration tool with rollback support
3. **atlas**: Modern schema management

### Example Migration Structure

```
migrations/
├── 000001_create_users_table.up.sql
├── 000001_create_users_table.down.sql
├── 000002_create_snippets_table.up.sql
├── 000002_create_snippets_table.down.sql
├── 000003_add_indexes.up.sql
└── 000003_add_indexes.down.sql
```

---

## Monitoring Queries

### Check Active Connections

```sql
SELECT count(*) FROM pg_stat_activity WHERE datname = 'snippy';
```

### View Slow Queries

```sql
SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
WHERE mean_time > 100
ORDER BY mean_time DESC
LIMIT 10;
```

### Check Index Usage

```sql
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan ASC;
```

### Table Sizes

```sql
SELECT
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## Security Best Practices

1. **Password Hashing**: All passwords are hashed using Argon2id before storage
2. **SQL Injection Prevention**: All queries use parameterized statements
3. **Connection Encryption**: Use SSL/TLS in production (configure with `sslmode=require`)
4. **Least Privilege**: Create application-specific database user with minimal permissions
5. **Regular Backups**: Implement automated backup strategy
6. **Audit Logging**: Consider enabling PostgreSQL audit logging for production

---

## Production Checklist

- [ ] Enable SSL/TLS connections (`sslmode=require`)
- [ ] Use strong database password (not default)
- [ ] Limit database user permissions
- [ ] Set up automated backups
- [ ] Configure connection pooling based on load
- [ ] Monitor query performance
- [ ] Set up database replication for high availability
- [ ] Implement proper migration system
- [ ] Enable audit logging
- [ ] Regular security updates for PostgreSQL
